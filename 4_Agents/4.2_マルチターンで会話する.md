# 4.2 マルチターンで会話する

前節では基本的なエージェントの作成方法を学びました。しかし、実際のアプリケーションでは、ユーザーとエージェントが複数回のやり取りを行う「マルチターン会話」が必要になることがほとんどです。この節では、OpenAI Agents SDKを使ってマルチターン会話を実装する方法を学びましょう。

## 4.2.1 マルチターン会話の基本

マルチターン会話とは、ユーザーとエージェントが複数回のやり取りを行い、会話の文脈（コンテキスト）を維持しながら対話を続けることです。これにより、エージェントは過去のやり取りを参照して、より適切な応答を提供できるようになります。

OpenAI Agents SDKでは、会話履歴を管理するための方法として、会話履歴の手動管理があります。`to_input_list()`メソッドを使用して会話履歴を取得し、次の呼び出しに渡す方法です。

## 4.2.2 会話履歴の手動管理

会話履歴を手動で管理する方法は、シンプルで柔軟性が高いアプローチです。以下のサンプルコードで、その実装方法を見てみましょう：

```python
import asyncio
from agents import Agent, Runner
from dotenv import load_dotenv

async def main():
    load_dotenv()
    yosemat = Agent(
        name="my assistant",
        instructions="""\
あなたはYosematという名前のAIアシスタントです。あなたは日本語を話します。
ユーザーに何を聞かれようとも「はいこちらYosematです。」と答えてから応答します。
最後に余計な一言を言います。
    """,
        model="gpt-4.1-mini",
    )
    initial_run = await Runner.run(
        yosemat,
        input="こんにちは、あなたの名前は何ですか？",
    )
    yosemat_response = initial_run.final_output
    print(
        f"一回目の応答: \n{yosemat_response}"
    )  # はいこちらYosematです。私の名前はYosematです。今日は良い天気ですね。

    # 2回目の質問
    second_run = await Runner.run(
        yosemat,
        input=initial_run.to_input_list()
        + [
            {
                "role": "user",
                "content": "最後に発言した余計な一言をもう一度言ってください。",
            }
        ],
    )
    yosemat_response = second_run.final_output
    print(
        f"二回目の応答: \n{yosemat_response}"
    )  # はいこちらYosematです。今日は良い天気ですね。コーヒーでも飲みたくなりますね。

if __name__ == "__main__":
    asyncio.run(main())
```

このコードでは、以下の重要なステップがあります：

1. 最初の会話ターンを実行し、応答を取得します。
2. `initial_run.to_input_list()`メソッドを使用して、最初の会話ターンの履歴を取得します。
3. 新しいユーザーメッセージを追加して、2回目の会話ターンを実行します。
4. エージェントは前回の会話履歴を参照して、文脈を理解した応答を提供します。

`to_input_list()`メソッドは、会話履歴を以下のような形式のリストとして返します：

```python
[
    {"role": "user", "content": "こんにちは、あなたの名前は何ですか？"},
    {"role": "assistant", "content": "はいこちらYosematです。私の名前はYosematです。今日は良い天気ですね。"}
]
```

このリストに新しいメッセージを追加することで、会話を継続することができます。

## 4.2.3 会話の文脈を活用する

マルチターン会話の大きな利点は、エージェントが会話の文脈を理解し、それを活用できることです。例えば、以下のような会話の流れを考えてみましょう：

1. ユーザー: "東京の天気を教えてください。"
2. エージェント: "東京の天気は晴れです。気温は25度です。"
3. ユーザー: "大阪はどうですか？"
4. エージェント: "大阪の天気は曇りです。気温は23度です。"

3番目のメッセージでは、ユーザーは「大阪」としか言っていませんが、エージェントは前の会話から「天気について質問している」という文脈を理解し、適切な応答を提供できます。

## 4.2.4 AIとAIの会話

OpenAI Agents SDKを使用すると、AIエージェント同士の会話も実装できます。これは、複雑なタスクを分担したり、異なる専門知識を持つエージェント間で協力したりする場合に役立ちます。

以下は、質問者と回答者の2つのAIエージェントが会話するサンプルコードです：

```python
import asyncio
from agents import Agent, Runner
from dotenv import load_dotenv

async def main():
    load_dotenv()
    
    # 最初のAIエージェント（質問者）
    questioner = Agent(
        name="質問者",
        instructions="""\
あなたは好奇心旺盛な質問者です。相手のAIに対して、興味深い質問をします。
質問は常に日本語で行い、一度に1つだけ質問してください。
質問のトピックは科学、技術、歴史、文化など幅広い分野から選んでください。
相手の回答に対して、さらに掘り下げた質問をしてください。
""",
        model="gpt-4.1-nano",
    )
    
    # 2つ目のAIエージェント（回答者）
    responder = Agent(
        name="回答者",
        instructions="""\
あなたは知識豊富な回答者です。質問者からの質問に対して、正確で詳細な回答を提供します。
回答は常に日本語で行い、できるだけ具体的な例や事実を含めてください。
回答の最後には、「他に質問はありますか？」と付け加えてください。
""",
        model="gpt-4.1-mini",
    )
    
    # 会話の履歴
    conversation = []
    
    # 最初の質問
    initial_question = "人工知能の歴史について教えてください。"
    print(f"初期質問: {initial_question}")
    
    # 会話を5ターン続ける
    for turn in range(5):
        print(f"\n--- ターン {turn + 1} ---")
        
        # 回答者の応答を取得
        if turn == 0:
            # 初回は直接質問を使用
            responder_result = await Runner.run(
                responder,
                input=initial_question,
            )
        else:
            # 2回目以降は会話履歴を使用
            responder_result = await Runner.run(
                responder,
                input=conversation,
            )
            
        responder_response = responder_result.final_output
        print(f"回答者: {responder_response}")
        
        # 会話履歴を更新
        if turn == 0:
            conversation = [
                {"role": "user", "content": initial_question},
                {"role": "assistant", "content": responder_response},
            ]
        else:
            conversation.append({"role": "assistant", "content": responder_response})
        
        # 最終ターンなら終了
        if turn == 4:
            break
        
        # 質問者の次の質問を取得
        questioner_result = await Runner.run(
            questioner,
            input=conversation,
        )
        questioner_response = questioner_result.final_output
        print(f"質問者: {questioner_response}")
        
        # 会話履歴を更新
        conversation.append({"role": "user", "content": questioner_response})

if __name__ == "__main__":
    asyncio.run(main())
```

このコードでは、以下のような処理を行っています：

1. 「質問者」と「回答者」の2つのエージェントを作成します。それぞれ異なる指示と役割を持ちます。
2. 初期質問を設定し、会話を開始します。
3. 各ターンで、回答者がまず応答し、その後質問者が次の質問をします。
4. 会話履歴を更新しながら、5ターンの会話を続けます。

このようなAI同士の会話は、以下のような用途に活用できます：

- 複雑な問題解決のためのブレインストーミング
- 異なる視点からの情報分析
- 教育コンテンツの自動生成
- ロールプレイングによるシナリオのシミュレーション

## 4.2.5 会話履歴の管理と制限

長時間の会話では、会話履歴が大きくなりすぎる可能性があります。これは、以下の問題を引き起こす可能性があります：

1. トークン数の増加によるコスト増加
2. モデルのコンテキスト長の制限を超える
3. 古い会話の情報が新しい応答に不適切な影響を与える

これらの問題を解決するために、以下のような戦略を検討できます：

### 会話履歴の要約

長い会話履歴を要約して、重要な情報だけを保持する方法です：

```python
async def summarize_conversation(conversation):
    # 会話履歴を要約するエージェント
    summarizer = Agent(
        name="要約者",
        instructions="与えられた会話履歴を簡潔に要約してください。重要な情報だけを残してください。"
    )
    
    # 会話履歴を要約
    summary_result = await Runner.run(summarizer, f"以下の会話を要約してください：\n{conversation}")
    summary = summary_result.final_output
    
    # 要約を含む新しい会話履歴を作成
    new_conversation = [{"role": "system", "content": f"以下は過去の会話の要約です：\n{summary}"}]
    
    return new_conversation
```

### 会話履歴の一部を保持

最新のN回の会話だけを保持する方法です：

```python
def keep_recent_messages(conversation, n=5):
    if len(conversation) > n * 2:  # ユーザーとエージェントのメッセージペアをn組保持
        return conversation[-n*2:]
    return conversation
```

## まとめ

この節では、OpenAI Agents SDKを使ったマルチターン会話の実装方法を学びました。会話履歴の手動管理の方法を紹介し、会話の文脈を活用する方法や会話履歴の管理と制限についても説明しました。また、AIエージェント同士の会話を実装する方法も学びました。

マルチターン会話を実装することで、エージェントはより自然で文脈を理解した対話を提供できるようになります。これは、チャットボット、カスタマーサポート、パーソナルアシスタントなど、多くのアプリケーションで重要な機能です。

次の節では、エージェントの出力形式を指定する方法について学び、構造化されたデータを扱う方法を探っていきます。