# 4.3 出力形式を指定する

前節までで、基本的なエージェントの作成方法とマルチターン会話の実装方法を学びました。この節では、エージェントの出力形式を指定する方法について学び、構造化されたデータを扱う方法を探っていきます。

## 4.3.1 構造化出力の必要性

通常、エージェントの応答はテキスト形式で返されます。これは人間との対話には適していますが、アプリケーションで応答を処理する場合、以下のような課題があります：

1. **応答の解析が必要**: テキスト応答から必要な情報を抽出するには、正規表現や自然言語処理が必要になることがあります。
2. **形式の一貫性がない**: 同じ質問に対しても、応答の形式が毎回異なる可能性があります。
3. **データの検証ができない**: テキスト応答には型やバリデーションの概念がありません。

これらの課題を解決するために、OpenAI Agents SDKでは**構造化出力**の機能が提供されています。構造化出力を使用すると、エージェントの応答を特定のデータ構造に強制することができます。

## 4.3.2 Pydanticモデルを使用した構造化出力

OpenAI Agents SDKでは、Pydanticモデルを使用して構造化出力を定義します。以下のサンプルコードで、その実装方法を見てみましょう：

```python
import asyncio
from agents import Agent, Runner
from dotenv import load_dotenv
from pydantic import BaseModel

class Country(BaseModel):
    name: str
    capital: str

async def main():
    load_dotenv()
    agent = Agent(
        name="assistant",
        instructions="""\
あなたは国名と首都名を知っているAIアシスタントです。ユーザーに国について質問されると、国名と首都名を答えます。
    """,
        output_type=Country,
        model="gpt-4.1-nano",
    )
    response = await Runner.run(
        agent,
        input="世界で一番人口が多い国はどこですか？",
    )
    print(response.final_output_as(Country))

if __name__ == "__main__":
    asyncio.run(main())
```

このコードでは、以下の重要なステップがあります：

1. `Country`というPydanticモデルを定義し、`name`と`capital`というフィールドを持たせています。
2. エージェントの作成時に`output_type=Country`を指定しています。
3. 応答を取得する際に`final_output_as(Country)`メソッドを使用して、構造化されたデータとして取得しています。

実行結果は以下のようになります：

```
Country(name='中国', capital='北京')
```

エージェントは、質問に対する応答を`Country`モデルの形式で返します。これにより、応答から国名と首都名を簡単に取得できます：

```python
country = response.final_output_as(Country)
print(f"国名: {country.name}")
print(f"首都: {country.capital}")
```

## 4.3.3 複雑な構造化出力

より複雑なデータ構造も定義できます。例えば、国の詳細情報を含むモデルを考えてみましょう：

```python
from typing import List, Optional
from pydantic import BaseModel

class Population(BaseModel):
    total: int
    year: int

class Geography(BaseModel):
    area: float  # 平方キロメートル
    continent: str

class Country(BaseModel):
    name: str
    capital: str
    population: Population
    languages: List[str]
    geography: Geography
    description: Optional[str] = None

# エージェントの作成
detailed_agent = Agent(
    name="国情報アシスタント",
    instructions="""
    あなたは国に関する詳細情報を提供するアシスタントです。
    ユーザーが国について質問したら、その国の詳細情報を提供してください。
    情報が不明な場合は、最善の推測を行ってください。
    """,
    output_type=Country,
    model="gpt-4o",  # より高性能なモデルを使用
)
```

このように複雑なモデルを定義することで、エージェントからより詳細な構造化データを取得できます。

## 4.3.4 構造化出力の利点

構造化出力を使用する主な利点は以下の通りです：

1. **データの一貫性**: 応答が常に同じ構造で返されるため、処理が容易になります。
2. **型安全性**: Pydanticの型チェックとバリデーションにより、データの整合性が保証されます。
3. **自動ドキュメント生成**: Pydanticモデルから自動的にAPIドキュメントを生成できます。
4. **統合の容易さ**: データベースやフロントエンドとの統合が容易になります。

## 4.3.5 構造化出力の制約と対策

構造化出力には、いくつかの制約や注意点もあります：

1. **柔軟性の低下**: 厳格な構造を強制するため、エージェントの応答の柔軟性が低下する可能性があります。
2. **モデルの能力に依存**: 複雑な構造を正確に生成するには、より高性能なモデルが必要になることがあります。
3. **エラー処理の必要性**: モデルが指定された構造を生成できない場合のエラー処理が必要です。

これらの制約に対処するためのいくつかの戦略を紹介します：

### フォールバックメカニズム

構造化出力の生成に失敗した場合に、テキスト応答にフォールバックする方法です：

```python
try:
    structured_response = response.final_output_as(Country)
    print(f"国名: {structured_response.name}")
    print(f"首都: {structured_response.capital}")
except Exception as e:
    print(f"構造化出力の解析に失敗しました: {e}")
    print(f"テキスト応答: {response.final_output}")
```

### 段階的なアプローチ

まず基本的な情報を構造化し、必要に応じて詳細情報を追加で取得する方法です：

```python
# 基本情報の取得
basic_response = await Runner.run(
    agent,
    input="日本について教えてください",
    output_type=BasicCountry,  # 基本的な情報のみを含むモデル
)

# 詳細情報が必要な場合
if need_details:
    detailed_response = await Runner.run(
        detailed_agent,
        input=f"{basic_response.final_output_as(BasicCountry).name}の詳細情報を教えてください",
        output_type=DetailedCountry,  # 詳細情報を含むモデル
    )
```

## 4.3.6 実践的な応用例

構造化出力は、様々なアプリケーションで活用できます。以下にいくつかの応用例を紹介します：

### Webアプリケーションとの統合

```python
from fastapi import FastAPI
from agents import Agent, Runner
from pydantic import BaseModel

class WeatherInfo(BaseModel):
    city: str
    temperature: float
    condition: str
    humidity: int

app = FastAPI()
weather_agent = Agent(
    name="天気情報アシスタント",
    instructions="あなたは天気情報を提供するアシスタントです。",
    output_type=WeatherInfo,
)

@app.get("/weather/{city}")
async def get_weather(city: str):
    response = await Runner.run(
        weather_agent,
        input=f"{city}の天気を教えてください",
    )
    return response.final_output_as(WeatherInfo)
```

### データ分析と可視化

```python
import matplotlib.pyplot as plt
from agents import Agent, Runner
from pydantic import BaseModel
from typing import List

class DataPoint(BaseModel):
    x: float
    y: float

class DataSeries(BaseModel):
    title: str
    points: List[DataPoint]

data_agent = Agent(
    name="データ分析アシスタント",
    instructions="あなたはデータ分析を支援するアシスタントです。",
    output_type=DataSeries,
)

async def visualize_data(description: str):
    response = await Runner.run(
        data_agent,
        input=f"以下の説明に基づいてデータポイントを生成してください: {description}",
    )
    data = response.final_output_as(DataSeries)
    
    x = [point.x for point in data.points]
    y = [point.y for point in data.points]
    
    plt.figure(figsize=(10, 6))
    plt.plot(x, y, 'o-')
    plt.title(data.title)
    plt.grid(True)
    plt.show()
```

## まとめ

この節では、OpenAI Agents SDKを使った構造化出力の実装方法を学びました。Pydanticモデルを使用して出力形式を定義し、エージェントの応答を特定のデータ構造に強制する方法を説明しました。また、構造化出力の利点と制約、そして実践的な応用例についても紹介しました。

構造化出力を活用することで、エージェントの応答をアプリケーションで効率的に処理できるようになり、より高度で信頼性の高いAIアプリケーションを開発することができます。

次の章では、エージェントのデバッグとモニタリングの方法について学び、エージェントの動作を理解し、問題を特定・解決する方法を探っていきます。